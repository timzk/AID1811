day04回顾
1.poll方法实现IO多路复用
  p = poll()创建poll对象
  p.register()
  p.poll() 阻塞等待poll事件的发生
2.epoll方法实现IO多路复用
  * 效率高于select 和poll
  * 触发方式更多,边缘触发(EPOLLET)
  * 能够监控更多的IO
3.struct 模块
  功能: 将一组数据结构转化为bytes,或者将字节串解析为元组
  st = Struct(fmt)
  st.pack() 将一组数据转换为bytes字串
  st.unpack() 将bytes字串解析为一组数据
4.本地套接字
  功能: 用于本地两个进程间通信
  sockfd = socket(AF_UNIX,SOCK_STREAM)
5.多任务编程和进程
  * 并发和并行
  * 什么是进程  进程是指一个程序开始到结束的一个过程,有生命周期
  * 进程的状态,就绪,执行,阻塞
  * PID,父子进程,PCB
6.os.fork()创建新的进程 
  特点:
  1).子进程会复制父进程全部的内存空间和代码段
  2).子进程会从fork的下一句开始执行
  3).if  elif else结构正是根据父子进程fork的返回值不同让父子进程
   ) 执行不同的内容,几乎是fork的固定搭配
  4).父子进程运行互不影响,使用同一个终端,运行顺序不定
  5).子进程有自己特有的PID,PCB,命令集等
  6).进入阻塞状态的进程一定会让出cpu时间片
  7).子进程连同fork之前开辟的空间也会复制,但是父子进程各自空间独立,操作各自空间内容,互不影响
7.进程相关函数使用
  os.getpid()
  功能: 获取当前进程的PID号
  返回值: 返回PID号

  os.getppid()
  功能:获取父进程的PID号
  返回值:返回父进程的PID号

  os._exit(status)
  功能: 退出一个进程
  参数: 表示进程退出状态 整数,退出后之后代码不会执行

  sys.exit([status])
  功能: 退出一个进程
  参数: 默认为0 整数表示进程退出状态
       字符串  则在进程退出时打印该字符串

三.孤儿进程和僵尸进程

  孤儿进程:父进程先于子进程退出此时子进程为孤儿进程
  * 孤儿进程会被系统进程收养,此时系统进程就会成为该进程新的父进程(一般为固定的)

  僵尸进程:子进程先于父进程退出,父进程没有处理子进程的退出状态
  * 僵尸进程虽然结束但是会存留部分PCB在内存,大量僵尸进程会占用内容资源

  如何处理僵尸进程
    1. 父进程中使用函数处理子进程退出状态
       pid,status = os.wait()
       功能: 阻塞等待处理子进程退出
       返回值:pid 退出的子进程的PID
            status 子进程的退出状态
       pid, status = os.waitpid(pid, option)
       功能:阻塞等待处理子进程退出
       参数:pid -1 表示等待任意进程退出
           pid  >0  等待指定PID的子进程退出
           option  0  表示阻塞等待
                  WNOHANG 表示非阻塞
       返回值:pid 退出的子进程的PID
            status 子进程的退出状态
    2. 创建二级子进程
       [1] 父进程创建子进程等待子进程退出
       [2] 子进程创建二级子进程立即退出
       [3] 将事件交由父进程和二级子进程完成,一级子进程被回收,二级子进程成为孤儿
           ,都不会被变成僵尸
        
------------------------------------------------------------
作业： 1. 梳理聊天室代码思路
      2. 整理fork创建进程内容
      3. 用fork创建父子进程，同时复制一个文件，
         各复制一半到一个新的文件中