day17回顾
面向对象编程思想
  对象是指物体或实体
  面向对象把一切东西看成是物体或实体

对象的特征:
  属性
    实例属性(实例变量)来记录对象自身的数据,属性是依赖某个对象的变量
  行为
    实例方法来描述对象的行为

类--->对象(实例方法------>实例属性)
类是用来描述对象,创建对象的"工厂"
class 语句:
  语法:
    class类名(继承列表):
        实例方法
        初始化方法
        析构方法
        类变量
        类方法
        静态方法
构造函数:
  类名(调用传参) #创建实例instance(对象object)

实例方法
  class myclass:
        def 方法名1(self,形参列表...):
            语句块
        def __init__(self,bianliang形参列表...):
            '''初始化方法''bianliang'
            self.name = 'nobianliang name'
        def ___del__(self):bianliang
            '''析构方法'''
        
实例属性:
  最好在方法内创建
预置实例属性:
  __dict__属性
    绑定存储此对象的实例属性的字典
  __class__属性
    绑定创建此对象的类
isinstance(obj,类或元组) #判断是否是某种类型
type(obj)类型返回

----------------------------------------------------
day18笔记
类属性(也叫类变量)
  类属性是类的变量,此属性属于类,不属于此类的实例

作用:
  通常用来记录该类创建的对象的共有属性
说明:
  类属性可以通过该类直接访问
  类属性可以通过类的实例直接访问,h1 = Human()  h1.count,优先访问实例属性(当实例属性不存在时才访问类属性) 
  类属性可以通过此类的对象的__class__属性间接访问

  示例:
    class_attribute.py

类的文档字符串:
  类内第一个没有赋值给任何变量的字符串为类的文档字符串
  类的文档字符串可以通过help函数查看
  类的文档字符串可以用类的__doc__属性访问

  示例:
    class Dog:
       '''这个类的文档字符串
          此字符串用来描述Dog对象的行为'''
          def eat(self,food):
             #'此方法用于描述小狗吃东西的方法'
             pass
    >>>help(Dog)
    >>>print(Dog.__doc__)

类的__slots__列表
  作用:
    1.限定一个类创建的实例只能有固定的实例属性,不允许添加此列表意外的实例属性
    2.防止因错误实例属性的名称而发生程序逻辑错误
  说明:
    1.__slots__属性是一个列表,列表的值是字符串
    2.含有__slots__属性的类所创建的实例对象没有__dict__属性
      即此实例不用字典来存储对象的实例属性
  示例:
    class_slots.py
    
类方法 @classmethod
  类方法是用于描述类的行为的方法,类方法属于类,不属于类的实例
  说明:
    类方法需要使用@classmethod装饰器定义
    类方法至少有一个形参,第一个形参用于绑定类,约定写为'cls'
    类和该类的实例都可以调用类方法
    类方法不能访问此类创建的对象的实例属性
  示例:
    class_method.py

静态方法@staticmethod
  静态方法是定义在类内部的函数,此函数的作用域是类的内部

  说明:
    静态方法需要使用@staticmethod装饰器定义
    静态方法与普通函数定义相同,不需要传入self和cls参数
    静态方法只能凭借该类或类创建的实例调用
    静态方法不能访问类属性和实例属性
  示例:
    static_method.py


继承(inheritance)
  继承是指从已有的类中派生出新类,新类具有原类的数据属性和行为并能扩展新的行为

名词:
  继承/派生
    派生是指从源类衍生出新的
为什么继承/派生
  继承的目的是延续旧类的功能
  派生的目的是在旧类的基础上添加新的功能
作用:
  用继承派生机制,可以将一些共有功能加在基类中,实现代码的共享
  在不改变基类的代码的基础上改变原有类的功能
名词:
  基类(base class)/超类(super class)/父类(father class)
  派生类(derived class)/子类(child class)

单继承
  单继承是指一个派生类由一个基类衍生出来的

  语法:
    class 类名(基类名):
        语句块
  示例:
    inherit.py

继承说明:
  python3 中任何类都直接或间接的继承自object类
  object类是一切类的基类

类的__base__属性
  __base__属性用来记录此类的基类

python3 的类的继承关系:
  >>>help(__builtins__)
---------------------------------------------
覆盖 override
  说明:*****************************************
    覆盖是指在有继承关系的类中,子类实现了与基类同名的方法,在子类的实例调用该方法时,
    实际调用的是子类中的覆盖版本,这种现象叫覆盖
  作用:
    修改父类的功能(行为)
  示例:
  class A:
      def work(self):
          print("A.work被调用")
  class B(A):
      def work(self):
          print("B.work被调用")
  b = B()
  b.work()
问题:
  当覆盖发生时,子类对象能否调用父类中的被覆盖方法

子类对象显示调用基类方法的方式:
  基类名.方法名(实例,实例调用参数)
  A.work(b)

super 函数:
  作用:
    借助super() 返回的实例间接调用其父类的覆盖方法
  语法:
    super(cls,obj) 返回绑定超类的实例(要求obj必须为cls类型或cls子类的对象)
    super()返回绑定超类的实例,等同于:super(self.__class__,实例方法的第一个参数),必须在方法内调用
  示例:
    class A:
        def work(self):
            print("A.work被调用")

    class B(A):
        def work(self):
            print("B.work被调用")
    b = B()
    super(B,b).work()  #查找上一层


显示调用基类的初始化方法__init__
  当子类中实现了__init__方法,基类的初始化方法并不会被调用
  此时需要显示调用父类的初始化方法来初始化父类对象

  示例:
  super_init.py

    