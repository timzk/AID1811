day05回顾
循环
    for 语句
        遍历可迭代对象
            语法:
                for 变量列表 in 可迭代对象
                语句块1
                else:
                语句块2
    可迭代对象:
        字符串str
        列表list
        range()返回回来的对象
        以及后面所学的所有容器类都是可迭代对象
    range函数
        range(终止整数)
        range(开始整数,终止整数)
        range(，，步长)
    contine 语句:
        用于重新开始一次新的循环
        　while a>b:

            contine
        for x in "abc":
            contine
列表容器
        可以存储任意数据的容器
        可变的序列
列表的创建　:
    字面值的创建方式
        [],[1,2,3,4,][1,2,[3,4,[5,6]]
    构造函数的创建方式
    　　list()
        list("ABC")
        list(range(1,10))
        list([1,2,3,4])
    列表的运算:
        + += * *=
        列表+=　可迭代对象（实现追加可迭代对象内的数据）
    列表的运算比较:
    　＜　＜＝　＞　＞＝　＝＝　！＝
        依次比较
        in / not in 运算符
------------------------------------------------------------------------
day06笔记

列表的索引操作
    index
索引的语法:
    列表[整数表达式]
用法:
    等同于字符串的索引
    索引分为正向索引和反向索引,规则与字符串的规则完全相同
示例:
　　Ｌ=[1,2,3,4,5]
    print(L[1])  #2
    print(L[-1]) #5
列表的索引赋值操作
    列表是可变的序列,可以通过索引赋值改变列表中的元素

    语法:
        列表[整数表达式]　＝　表达式
    示例:
        L = [1,-2,3,-4,5]
        L[1]=2
        print(L) #[1,2,3,-4,5]
        L[-2] = 4
        print(L) #[1,2,3,4,5]
列表的切片
    列表[:]
    列表[::]
    列表的切片是从列表中取出相应的元素，重新组成一个新的列表
    列表的切片规则等同于字符串的切片规则

    示例:
    L=[0,1,2,3,4,5,6,7,8]
    L2=L[1:9:2] #L2 = [1,3,5,7]
    L=[-100:10000] #[0,1,2,3,4,5,6,7,8]  越界后输出全部

列表的切片赋值
    作用:
        可以改变原列表的排序,可以插入，删除和修改数据
    语法:
        列表[切片slice]=可迭代对象
    说明:
        赋值运算符的右侧必须是可迭代对象
    示例:
        L=[2,3.1,4.2,5]
        L[1:3] =[3,4] #L=[2,3,4,5]
        L=[2,4]
        L[1:1] =[3] #L=[2,3,4] #填满空处
        L[5:5]=[5,6] #L=[0,1,2,3,4,5,6]
        L[0,0] ="AB" #L=['A','B',2,4]
        L[::] =[] #清空,不等同于 L=[], 把原来的列表清空，内存地址是不会改变的，L=[] 这是表示创建一个新的空列表，绑定到变量Ｌ里面
    注意事项:
    　L=[1,2,3,4,]
     L2=L2
     L=[]
     print(L2)

     L=[1,2,3,4,]
     L2= L
     L[:]=[] #此处与上面不同  
     print(L2)  #列表是一直存在与内存中的Ｌ２＝Ｌ并不是　Ｌ２就赋予一个新的值，而是同时拥有了Ｌ的值
del 语句
    用于删除列表中的元素
    语法：
        del 列表［索引］
        del 列表[切片]　　del  L[1::2]
    示例:
        L=[1,3.14,2,100,3]
        del L[1]
        del L[2]
        print(L)
    说明:
        列表中的元素被删除，后续元素的索引值会变小，即后续元素前移
    列表的切片操作注意事项:
     对于步长不等于1的切片赋值，赋值运算符右侧的可迭代对象提供的元素个数，一定要等于切片切出的段数
     如：
        L= [1,2,3,4,5,6]
        L[::2]＝"ＡＢＣ"　＃正确，刚好等于步长
        L[::2]="ABCDE"  #错误，超出步长切出的数据

python3 中常用的序列函数
 len(seq) 返回序列的长度
 max(x)返回序列的最大值元素（要求每两个元素都能比较大小）
 min(x)返回序列的最小值元素
 sum(x)返回序列中所有元素的和(元素必须是数值类型)
 any(x)真值测试，如果列表中其中一个值为真值，则返回Ｔrue
 all(x)真值测试，如果列表中所有值都为真值才返回Ｔrue，否则返回　False

示例：
　Ｌ＝[1,3.14,0,99999,10]
 len(Ｌ)　　＃５
 max(Ｌ)　＃９９９９９９
 min(L) #0
 sum (L)
 amy(L) #True
 all(L) #False

序列相关的函数２
 reversed(seq) 返回原序列的方向顺序的可迭代对象
 sorted(seq,reversed=False) 返回可迭代对象中排序后的对象的列表

示例：
　L = [5,9,7,1,3]
 for x in reversed(L):
    print(x) #3 1 7 9 5 #原来顺序的反向
 L2 = sorted(L) #L2= [1,3,5,7,9] 默认是顺序排序
 L3 = sorted(L,reversed=True) #L3= [9,7,5,3,1]

python3 中常用的列表方法(method)
    详见:　＞＞＞＞help(list)
    L.insert(index, obj) L= [3,5] L.insert(1,4) #从索引为１的位置插入数值为４的数据
    L.count(x)　　L=[1,2,3,3,4] L.count(3) #2 查找数字３在列表中存在的次数
    L.remove(x)　＃删除列表中等同于x的值
    L.copy()　　＃复制一个列表重新赋值到另一个变量
    L.append(x)　＃追加在索引最后的一个位置
    L.pop([索引])　　移除（取出）　返回取出来的数据
    L.sorted(range())

深拷贝　和　浅拷贝
1.不拷贝
    L1=[1,2,[3.1,3.2]]
    L2=L1 #没拷贝:两个变量同时绑定在一个对象上,只复制一层，深层对象共同拥有
    L2[1]=2.2
    L2[2][0] = 3.14  #把3.1改为了3.14
    print(L2)
    print(L1)
2.浅拷贝shallow copy
    浅拷贝是指在复制过程中，只复制一层变量(只管第一层列表数据，最里面的那层),不会复制深层变量绑定的对象的复制过程
    只复制一层，深层对象共同拥有
    示例:
    L1=[1,2,[3.1,3.2]]
    L2=L.copy #浅拷贝:两个变量同时绑定在一个对象上
    L2[1]=2.2
    L2[2][0] = 3.14  #把3.1改为了3.14
    print(L2)　　＃1,2.2,[3.14,3.2]
    print(L1)   #[1,2,[3.14,3.2]] 此时L1中的第二层被发深改变了，所以，L1也会跟着改变
3.深拷贝　deep copy 如果存在两层列表关系的话就用此函数
    深拷贝是指在复制过程中，复制所有变量及变量关联的深层变量绑定对象，实现两个对象完全独立
    示例:
    import copy  #导入复制模块()
    L1=[1,2,[3.1,3.2]]
    L2=copy.deepcopy(L1) #浅拷贝:两个变量同时绑定在一个对象上
    L2[1]=2.2
    L2[2][0] = 3.14  #把3.1改为了3.14
    print(L2)　　＃1,2.2,[3.14,3.2]
    print(L1)   #[1,2,[3.1,3.2]] 

    列表和字符串比较
        列表和字符串都是序列，元素之间先后顺序关系
        字符串是不可以改变的序列，列表是可以改变的序列
        字符串只能存储字符，而列表可以存储任意类型的对象
        列表和字符串都是可迭代对象

    不可变数据类型:
        占用内存相对较小，数据安全，单不能实现添加，删除修改等操作
    可变数据类型
        占用内存较多，可以实现灵活的添加，删除，修改等操作



    字符串文本解析方法split,splitlines 和join
    S.split(sep=None)将字符串使用sep作用分隔符分割S字符串,返回分割之后的字符串列表，当不给定参数时，用空白字符作为分隔符
    S.splitlines(sep=None)将字符串以行为单位进行分割，形成分割后的列表
    S.join(iterable)用可迭代对象中的字符串,返回一个中间用S进行分隔字符串
    示例：
        s = 'Beijing is capital'
        L = s.split(' ') #L=['Beijing','is','capital']
        L2 = ['c','programe','python3']
        path = '\\'.join(L2) #c\programe\python3 #用\进行拼接连接字符串

    列表推导式　list comprehension
        列表推导式是用可迭代对象来创建ｃｅｌｉａ的表达式

        作用：
            用简易方法创建列表
        语法：
        [表达式 for 变量 in 可迭代对象]
        或
        ［表达式 for 变量　in 可迭代对象 if 真值表达式］
        示例：
            生成一个数字1~9的整数的平方的列表,即：
            L = [1,4,9,16,25...81]
            L = []
            for x in range(1,10):
                L.append(x **2)
            print(L)
        ---------以下为推导式---------
        L2 = [x**2 for x in range(1,10) if x % 2==1] #添加if语句求与后是否是基数
        print(L2)
    列表推导式的嵌套：
        [表达式1 
                for 变量1 in 可迭代对象1 if 真值表达式1
                    for 变量2 in 可迭代对象2 if 真值表达式2
                    ...]
    示例：
        L= [x+y for x in [10,20,30]for y in [1,2,3]]
        print(L) #[11,12,13,21,22,23,31,32,33]


1, 3, 2, 1, 6, 4, 2, ...., 98, 82
1 ,3, 2, 1, 6, 4, 2,9,8,7

    



